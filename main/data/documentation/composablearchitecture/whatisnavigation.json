{"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"State-driven navigation broadly falls into 2 main categories: tree-based, where you use optionals"},{"type":"text","text":" "},{"type":"text","text":"and enums to model navigation, and stack-based, where you use flat collections to model navigation."},{"text":" ","type":"text"},{"text":"Nearly all navigations will use a combination of the two styles, but it is important to know","type":"text"},{"type":"text","text":" "},{"type":"text","text":"their strengths and weaknesses."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"#Tree-based-navigation","isActive":true}]}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"#Stack-based-navigation"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","isActive":true,"identifier":"#Tree-based-vs-stack-based-navigation"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"identifier":"#Pros-of-tree-based-navigation","isActive":true,"type":"reference"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"#Cons-of-tree-based-navigation","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"#Pros-of-stack-based-navigation","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"identifier":"#Cons-of-stack-based-navigation","isActive":true,"type":"reference"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"level":2,"text":"Defining navigation","anchor":"Defining-navigation","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The word “navigation” can mean a lot of different things to different people. For example, most"},{"type":"text","text":" "},{"text":"people would say that an example of “navigation” is the drill-down style of navigation afforded to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"us by "},{"type":"codeVoice","code":"NavigationStack"},{"text":" in SwiftUI and ","type":"text"},{"code":"UINavigationController","type":"codeVoice"},{"type":"text","text":" in UIKit “navigation”."},{"type":"text","text":" "},{"type":"text","text":"However, if drill-downs are considered navigation, then surely sheets and fullscreen covers should"},{"text":" ","type":"text"},{"text":"be too.  The only difference is that sheets and covers animate from bottom-to-top instead of from","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"right-to-left, but is that actually substantive?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And if sheets and covers are considered navigation, then certainly popovers should be too. We can"},{"type":"text","text":" "},{"text":"even expand our horizons to include more styles of navigation, such as alerts and confirmation","type":"text"},{"type":"text","text":" "},{"text":"dialogs, and even custom forms of navigation that are not handed down to us from Apple.","type":"text"}]},{"inlineContent":[{"type":"text","text":"So, for the purposes of this documentation, we will use the following loose definition of"},{"type":"text","text":" "},{"type":"text","text":"“navigation”:"}],"type":"paragraph"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"inlineContent":[{"type":"text","text":"Navigation"}],"type":"strong"},{"type":"text","text":" is a change of mode in the application."}]}],"name":"Definition"},{"inlineContent":[{"text":"Each of the examples we considered above, such as drill-downs, sheets, popovers, covers, alerts,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"dialogs, and more, are all a “change of mode” in the application."}],"type":"paragraph"},{"inlineContent":[{"text":"But, so far we have just defined one term, “navigation”, by using another undefined term,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"“change of mode”, so we will further make the following definition:"}],"type":"paragraph"},{"name":"Definition","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"change of mode"}],"type":"strong"},{"type":"text","text":" is when some piece of state goes from not existing to existing,"},{"type":"text","text":" "},{"type":"text","text":"or vice-versa."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, when a piece of state switches from not existing to existing, that represents a navigation and"},{"text":" ","type":"text"},{"text":"change of mode in the application, and when the state switches back to not existing, it represents","type":"text"},{"type":"text","text":" "},{"text":"undoing the navigation and returning to the previous mode.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"That is very abstract way of describing state-driven navigation, and the next two sections make","type":"text"},{"text":" ","type":"text"},{"text":"these concepts much more concrete for the two main forms of state-driven navigation:","type":"text"},{"type":"text","text":" "},{"overridingTitle":"tree-based","type":"reference","isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"tree-based"}],"identifier":"#Tree-based-navigation"},{"type":"text","text":" and "},{"overridingTitleInlineContent":[{"type":"text","text":"stack-based"}],"isActive":true,"identifier":"#Stack-based-navigation","type":"reference","overridingTitle":"stack-based"},{"text":" navigation.","type":"text"}]},{"type":"heading","level":2,"text":"Tree-based navigation","anchor":"Tree-based-navigation"},{"inlineContent":[{"text":"In the previous section we defined state-driven navigation as being controlled by the existence or","type":"text"},{"type":"text","text":" "},{"text":"non-existence of state. The term “existence” was not defined, and there are a few ways in which","type":"text"},{"text":" ","type":"text"},{"text":"existence can be defined. If we define the existence or non-existence of state as being represented","type":"text"},{"type":"text","text":" "},{"text":"by Swift’s ","type":"text"},{"type":"codeVoice","code":"Optional"},{"text":" type, then we call this “tree-based” navigation because when multiple states","type":"text"},{"type":"text","text":" "},{"text":"of navigation are nested they form a tree-like structure.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, suppose you have an inventory feature with a list of items such that tapping one of"},{"type":"text","text":" "},{"text":"those items performs a drill-down navigation to a detail screen for the item. Then that can be","type":"text"},{"text":" ","type":"text"},{"text":"modeled with the ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Presents()"},{"type":"text","text":" macro pointing to some optional state:"}],"type":"paragraph"},{"syntax":"swift","code":["@Reducer","struct InventoryFeature {","  @ObservableState","  struct State {","    @Presents var detailItem: DetailItemFeature.State?","    \/\/ ...","  }","  \/\/ ...","}"],"type":"codeListing"},{"inlineContent":[{"text":"Then, inside that detail screen there may be a button to edit the item in a sheet, and that too can","type":"text"},{"text":" ","type":"text"},{"text":"be modeled with the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Presents()","isActive":true},{"text":" macro pointing to a piece of optional state:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["@Reducer","struct DetailItemFeature {","  @ObservableState","  struct State {","    @Presents var editItem: EditItemFeature.State?","    \/\/ ...","  }","  \/\/ ...","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And further, inside the “edit item” feature there can be a piece of optional state that represents"},{"type":"text","text":" "},{"type":"text","text":"whether or not an alert is displayed:"}]},{"code":["@Reducer","struct EditItemFeature {","  struct State {","    @Presents var alert: AlertState<AlertAction>?","    \/\/ ...","  }","  \/\/ ...","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"And this can continue on and on for as many layers of navigation that exist in the application."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"With that done, the act of deep-linking into the application is a mere exercise in constructing"},{"type":"text","text":" "},{"type":"text","text":"a piece of deeply nested state. So, if we wanted to launch the inventory view into a state where"},{"type":"text","text":" "},{"text":"we are drilled down to a particular item ","type":"text"},{"inlineContent":[{"text":"with","type":"text"}],"type":"emphasis"},{"text":" the edit sheet opened ","type":"text"},{"inlineContent":[{"text":"and","type":"text"}],"type":"emphasis"},{"text":" an alert opened, we","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"simply need to construct the piece of state that represents the navigation:"}]},{"syntax":"swift","code":["InventoryView(","  store: Store(","    initialState: InventoryFeature.State(","      detailItem: DetailItemFeature.State(      \/\/ Drill-down to detail screen","        editItem: EditItemFeature.State(        \/\/ Open edit modal","          alert: AlertState {                   \/\/ Open alert","            TextState(\"This item is invalid.\")","          }","        )","      )","    )","  ) {","    InventoryFeature()","  }",")"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the above we can start to see the tree-like structure of this form of domain modeling. Each"},{"type":"text","text":" "},{"type":"text","text":"feature in your application represents a node of the tree, and each destination you can navigate to"},{"type":"text","text":" "},{"type":"text","text":"represents a branch from the node. Then the act of navigating to a new feature corresponds to"},{"type":"text","text":" "},{"type":"text","text":"building another nested piece of state."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That is the basics of tree-based navigation. Read the dedicated "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TreeBasedNavigation"},{"text":" article","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"for information on how to use the tools that come with the Composable Architecture to implement"},{"text":" ","type":"text"},{"type":"text","text":"tree-based navigation in your application."}]},{"anchor":"Stack-based-navigation","level":2,"text":"Stack-based navigation","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"In the ","type":"text"},{"overridingTitleInlineContent":[{"type":"text","text":"previous section"}],"type":"reference","identifier":"#Tree-based-navigation","overridingTitle":"previous section","isActive":true},{"text":" we defined “tree-based” navigation as the process","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of modeling the presentation of a child feature with optional state. This takes on a tree-like"},{"type":"text","text":" "},{"text":"structure in which a deeply nested feature is represented by a deeply nested piece of state.","type":"text"}]},{"inlineContent":[{"text":"There is another powerful tool for modeling the existence and non-existence of state for driving","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"navigation: collections. This is most used with SwiftUI’s "},{"type":"codeVoice","code":"NavigationStack"},{"type":"text","text":" view in which"},{"type":"text","text":" "},{"text":"an entire stack of features are represented by a collection of data. When an item is added to the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"collection it represents a new feature being pushed onto the stack, and when an item is removed from"},{"type":"text","text":" "},{"type":"text","text":"the collection it represents popping the feature off the stack."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Typically one defines an enum that holds all of the possible features that can be navigated to on"},{"text":" ","type":"text"},{"type":"text","text":"the stack, so continuing the analogy from the previous section, if an inventory list can navigate to"},{"text":" ","type":"text"},{"text":"a detail feature for an item and then navigate to an edit screen, this can be represented by:","type":"text"}],"type":"paragraph"},{"code":["enum Path {","  case detail(DetailItemFeature.State)","  case edit(EditItemFeature.State)","  \/\/ ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then a collection of these states represents the features that are presented on the stack:"}]},{"syntax":"swift","type":"codeListing","code":["let path: [Path] = [","  .detail(DetailItemFeature.State(item: item)),","  .edit(EditItemFeature.State(item: item)),","  \/\/ ...","]"]},{"type":"paragraph","inlineContent":[{"text":"This collection of ","type":"text"},{"code":"Path","type":"codeVoice"},{"type":"text","text":" elements can be any length necessary, including very long to represent"},{"text":" ","type":"text"},{"type":"text","text":"being drilled down many layers deep, or even empty to represent that we are at the root of the"},{"type":"text","text":" "},{"text":"stack.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That is the basics of stack-based navigation. Read the dedicated"},{"text":" ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/StackBasedNavigation","type":"reference","isActive":true},{"type":"text","text":" article for information on how to use the tools that come with the"},{"text":" ","type":"text"},{"text":"Composable Architecture to implement stack-based navigation in your application.","type":"text"}]},{"level":2,"anchor":"Tree-based-vs-stack-based-navigation","text":"Tree-based vs stack-based navigation","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Most real-world applications will use a mixture of tree-based and stack-based navigation. For","type":"text"},{"type":"text","text":" "},{"type":"text","text":"example, the root of your application may use stack-based navigation with a"},{"type":"text","text":" "},{"type":"codeVoice","code":"NavigationStack"},{"text":" view, but then each feature inside the stack may use tree-based","type":"text"},{"text":" ","type":"text"},{"text":"navigation for showing sheets, popovers, alerts, etc. But, there are pros and cons to each form of","type":"text"},{"type":"text","text":" "},{"text":"navigation, and so it can be important to be aware of their differences when modeling your domains.","type":"text"}]},{"anchor":"Pros-of-tree-based-navigation","type":"heading","text":"Pros of tree-based navigation","level":4},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tree-based navigation is a very concise way of modeling navigation. You get to statically"},{"text":" ","type":"text"},{"type":"text","text":"describe all of the various navigation paths that are valid for your application, and that makes"},{"type":"text","text":" "},{"text":"it impossible to restore a navigation that is invalid for your application. For example, if it","type":"text"},{"type":"text","text":" "},{"text":"only makes sense to navigate to an “edit” screen after a “detail” screen, then your detail","type":"text"},{"type":"text","text":" "},{"type":"text","text":"feature needs only to hold onto a piece of optional edit state:"}]},{"code":["@ObservableState","struct State {","  @Presents var editItem: EditItemFeature.State?","  \/\/ ...","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"This statically enforces the relationship that we can only navigate to the edit screen from the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"detail screen."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Related to the previous pro, tree-based navigation also allows you to describe the finite number","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of navigation paths that your app supports."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you modularize the features of your application, then those feature modules will be more"},{"type":"text","text":" "},{"text":"self-contained when built with the tools of tree-based navigation. This means that Xcode","type":"text"},{"type":"text","text":" "},{"text":"previews and preview apps built for the feature will be fully functional.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if you have a "},{"type":"codeVoice","code":"DetailFeature"},{"text":" module that holds all of the logic and views for the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"detail feature, then you will be able to navigate to the edit feature in previews because the"},{"text":" ","type":"text"},{"type":"text","text":"edit feature’s domain is directly embedded in the detail feature."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Related to the previous pro, because features are tightly integrated together it makes writing"},{"type":"text","text":" "},{"text":"unit tests for their integration very simple. You can write deep and nuanced tests that assert","type":"text"},{"text":" ","type":"text"},{"text":"how the detail feature and edit feature integrate together, allowing you to prove that they","type":"text"},{"text":" ","type":"text"},{"text":"interact in the correct way.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Tree-based navigation unifies all forms of navigation into a single, concise style of API,","type":"text"},{"text":" ","type":"text"},{"text":"including drill-downs, sheets, popovers, covers, alerts, dialogs and a lot more. See","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TreeBasedNavigation#API-Unification"},{"type":"text","text":" for more information."}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Cons of tree-based navigation","type":"heading","level":4,"anchor":"Cons-of-tree-based-navigation"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Unfortunately it can be cumbersome to express complex or recursive navigation paths using"},{"type":"text","text":" "},{"type":"text","text":"tree-based navigation. For example, in a movie application you can navigate to a movie, then a"},{"text":" ","type":"text"},{"text":"list of actors in the movies, then to a particular actor, and then to the same movie you started","type":"text"},{"text":" ","type":"text"},{"text":"at. This creates a recursive dependency between features that can be difficult to model in Swift","type":"text"},{"type":"text","text":" "},{"type":"text","text":"data types."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"By design, tree-based navigation couples features together. If you can navigate to an edit"},{"text":" ","type":"text"},{"text":"feature from a detail feature, then you must be able to compile the entire edit feature in order","type":"text"},{"text":" ","type":"text"},{"text":"to compile the detail feature. This can eventually slow down compile times, especially when you","type":"text"},{"type":"text","text":" "},{"type":"text","text":"work on features closer to the root of the application since you must build all destination"},{"text":" ","type":"text"},{"type":"text","text":"features."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Historically, tree-based navigation is more susceptible to SwiftUI’s navigation bugs, in"},{"type":"text","text":" "},{"type":"text","text":"particular when dealing with drill-down navigation. However, many of these bugs have been fixed"},{"type":"text","text":" "},{"text":"in iOS 16.4 and so is less of a concern these days.","type":"text"}]}]}]},{"anchor":"Pros-of-stack-based-navigation","type":"heading","text":"Pros of stack-based navigation","level":4},{"items":[{"content":[{"inlineContent":[{"text":"Stack-based navigation can easily handle complex and recursive navigation paths. The example we","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"considered earlier, that of navigating through movies and actors, is handily accomplished with"},{"text":" ","type":"text"},{"type":"text","text":"an array of feature states:"}],"type":"paragraph"},{"syntax":"swift","code":["let path: [Path] = [","  .movie(\/* ... *\/),","  .actors(\/* ... *\/),","  .actor(\/* ... *\/),","  .movies(\/* ... *\/),","  .movie(\/* ... *\/),","]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Notice that we start on the movie feature and end on the movie feature. There is no real","type":"text"},{"type":"text","text":" "},{"type":"text","text":"recursion in this navigation since it is just a flat array."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Each feature held in the stack can typically be fully decoupled from all other screens on the"},{"type":"text","text":" "},{"text":"stack. This means the features can be put into their own modules with no dependencies on each","type":"text"},{"text":" ","type":"text"},{"text":"other, and can be compiled without compiling any other features.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"NavigationStack"},{"type":"text","text":" API in SwiftUI typically has fewer bugs than"},{"text":" ","type":"text"},{"type":"codeVoice","code":"NavigationLink(isActive:)"},{"text":" and ","type":"text"},{"code":"navigationDestination(isPresented:)","type":"codeVoice"},{"type":"text","text":", which are used in tree-based"},{"type":"text","text":" "},{"text":"navigation. There are still a few bugs in ","type":"text"},{"type":"codeVoice","code":"NavigationStack"},{"type":"text","text":", but on average it is a lot"},{"type":"text","text":" "},{"type":"text","text":"more stable."}]}]}],"type":"unorderedList"},{"text":"Cons of stack-based navigation","type":"heading","anchor":"Cons-of-stack-based-navigation","level":4},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Stack-based navigation is not a concise tool. It makes it possible to express navigation"},{"text":" ","type":"text"},{"type":"text","text":"paths that are completely non-sensical. For example, even though it only makes sense to navigate"},{"type":"text","text":" "},{"text":"to an edit screen from a detail screen, in a stack it would be possible to present the features","type":"text"},{"type":"text","text":" "},{"text":"in the reverse order:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let path: [Path] = [","  .edit(\/* ... *\/),","  .detail(\/* ... *\/)","]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That is completely non-sensical. What does it mean to drill down to an edit screen and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"then"}]},{"text":" ","type":"text"},{"text":"a detail screen. You can create other non-sensical navigation paths, such as multiple edit","type":"text"},{"type":"text","text":" "},{"type":"text","text":"screens pushed on one after another:"}]},{"type":"codeListing","code":["let path: [Path] = [","  .edit(\/* ... *\/),","  .edit(\/* ... *\/),","  .edit(\/* ... *\/),","]"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This too is completely non-sensical, and it is a drawback to the stack-based approach when you"},{"text":" ","type":"text"},{"type":"text","text":"want a finite number of well-defined navigation paths in your app."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you were to modularize your application and put each feature in its own module, then those"},{"type":"text","text":" "},{"text":"features, when run in isolation in an Xcode preview, would be mostly inert. For example, a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"button in the detail feature for drilling down to the edit feature can’t possibly work in an"},{"text":" ","type":"text"},{"type":"text","text":"Xcode preview since the detail and edit features have been completely decoupled. This makes it"},{"type":"text","text":" "},{"type":"text","text":"so that you cannot test all of the functionality of the detail feature in an Xcode preview, and"},{"text":" ","type":"text"},{"type":"text","text":"instead have to resort to compiling and running the full application in order to preview"},{"text":" ","type":"text"},{"text":"everything.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Related to the above, it is also more difficult to unit test how multiple features integrate"},{"text":" ","type":"text"},{"type":"text","text":"with each other. Because features are fully decoupled we cannot easily test how the detail and"},{"type":"text","text":" "},{"text":"edit feature interact with each other. The only way to write that test is to compile and run the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"entire application."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"And finally, stack-based navigation and "},{"type":"codeVoice","code":"NavigationStack"},{"type":"text","text":" only applies to drill-downs"},{"text":" ","type":"text"},{"type":"text","text":"and does not address at all other forms of navigation, such as sheets, popovers, alerts, etc."},{"type":"text","text":" "},{"type":"text","text":"It’s still on you to do the work to decouple those kinds of navigations."}]}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"inlineContent":[{"text":"We have now defined the basic terms of navigation, in particular state-driven navigation, and we","type":"text"},{"type":"text","text":" "},{"type":"text","text":"have further divided navigation into two categories: tree-based and stack-based. Continue reading"},{"type":"text","text":" "},{"type":"text","text":"the dedicated articles "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TreeBasedNavigation","isActive":true,"type":"reference"},{"type":"text","text":" and "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/StackBasedNavigation","isActive":true,"type":"reference"},{"type":"text","text":" to learn about the"},{"type":"text","text":" "},{"text":"tools the Composable Architecture provides for modeling your domains and integrating features","type":"text"},{"type":"text","text":" "},{"type":"text","text":"together for navigation."}],"type":"paragraph"}]}],"schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"role":"article","roleHeading":"Article","modules":[{"name":"ComposableArchitecture"}],"title":"What is navigation?"},"variants":[{"paths":["\/documentation\/composablearchitecture\/whatisnavigation"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/WhatIsNavigation","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation"],["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation"]]},"kind":"article","sections":[],"abstract":[{"text":"Learn about the two main forms of state-driven navigation, tree-based and stack-based navigation,","type":"text"},{"type":"text","text":" "},{"text":"as well as their tradeoffs.","type":"text"}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/Navigation":{"kind":"article","abstract":[{"text":"Learn how to use the navigation tools in the library, including how to best model your domains, how","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to integrate features in the reducer and view layers, and how to write tests."}],"role":"collectionGroup","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","url":"\/documentation\/composablearchitecture\/navigation","title":"Navigation"},"#Cons-of-tree-based-navigation":{"titleInlineContent":[{"type":"text","text":"Cons of tree-based navigation"}],"identifier":"#Cons-of-tree-based-navigation","type":"link","url":"#Cons-of-tree-based-navigation","title":"Cons of tree-based navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/StackBasedNavigation":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/StackBasedNavigation","url":"\/documentation\/composablearchitecture\/stackbasednavigation","type":"topic","role":"article","abstract":[{"type":"text","text":"Learn about stack-based navigation, that is navigation modeled with collections, including how to"},{"text":" ","type":"text"},{"type":"text","text":"model your domains, how to integrate features, how to test your features, and more."}],"title":"Stack-based navigation","kind":"article"},"#Pros-of-tree-based-navigation":{"titleInlineContent":[{"type":"text","text":"Pros of tree-based navigation"}],"identifier":"#Pros-of-tree-based-navigation","type":"link","url":"#Pros-of-tree-based-navigation","title":"Pros of tree-based navigation"},"#Tree-based-navigation":{"titleInlineContent":[{"type":"text","text":"Tree-based navigation"}],"identifier":"#Tree-based-navigation","type":"link","url":"#Tree-based-navigation","title":"Tree-based navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","abstract":[{"text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"text":" ","type":"text"},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"role":"collection","type":"topic","kind":"symbol","url":"\/documentation\/composablearchitecture","title":"ComposableArchitecture"},"#Pros-of-stack-based-navigation":{"titleInlineContent":[{"type":"text","text":"Pros of stack-based navigation"}],"identifier":"#Pros-of-stack-based-navigation","type":"link","url":"#Pros-of-stack-based-navigation","title":"Pros of stack-based navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Presents()":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Presents()","url":"\/documentation\/composablearchitecture\/presents()","type":"topic","role":"symbol","abstract":[{"text":"Wraps a property with ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/PresentationState"},{"text":" and observes it.","type":"text"}],"fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Presents"},{"kind":"text","text":"()"}],"title":"Presents()","kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Effect":{"kind":"symbol","abstract":[],"url":"\/documentation\/composablearchitecture\/effect","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"navigatorTitle":[{"text":"Effect","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","title":"Effect","role":"symbol"},"#Stack-based-navigation":{"titleInlineContent":[{"type":"text","text":"Stack-based navigation"}],"identifier":"#Stack-based-navigation","type":"link","url":"#Stack-based-navigation","title":"Stack-based navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TreeBasedNavigation#API-Unification":{"url":"\/documentation\/composablearchitecture\/treebasednavigation#API-Unification","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TreeBasedNavigation#API-Unification","type":"topic","abstract":[],"kind":"section","title":"API Unification"},"#Cons-of-stack-based-navigation":{"titleInlineContent":[{"type":"text","text":"Cons of stack-based navigation"}],"identifier":"#Cons-of-stack-based-navigation","type":"link","url":"#Cons-of-stack-based-navigation","title":"Cons of stack-based navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/PresentationState":{"role":"symbol","navigatorTitle":[{"text":"PresentationState","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A property wrapper for state that can be presented."}],"url":"\/documentation\/composablearchitecture\/presentationstate","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/PresentationState","title":"PresentationState","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"PresentationState"}],"kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TreeBasedNavigation":{"kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TreeBasedNavigation","type":"topic","title":"Tree-based navigation","abstract":[{"type":"text","text":"Learn about tree-based navigation, that is navigation modeled with optionals and enums, including"},{"text":" ","type":"text"},{"type":"text","text":"how to model your domains, how to integrate features, how to test your features, and more."}],"role":"article","url":"\/documentation\/composablearchitecture\/treebasednavigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"url":"\/documentation\/composablearchitecture\/reducer","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"kind":"symbol","type":"topic","role":"symbol","abstract":[{"text":"A protocol that describes how to evolve the current state of an application to the next state,","type":"text"},{"text":" ","type":"text"},{"text":"given an action, and describes what ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":"s should be executed later by the store, if any."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"title":"Reducer"},"#Tree-based-vs-stack-based-navigation":{"titleInlineContent":[{"type":"text","text":"Tree-based vs stack-based navigation"}],"identifier":"#Tree-based-vs-stack-based-navigation","type":"link","url":"#Tree-based-vs-stack-based-navigation","title":"Tree-based vs stack-based navigation"}}}